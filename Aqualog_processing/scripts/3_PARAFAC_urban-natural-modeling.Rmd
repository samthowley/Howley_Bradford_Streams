---
title: "PARAFAC Model Template"
author: "Emily Taylor"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_depth: '2'
    df_print: paged
  pdf_document:
    fig_crop: yes
    toc: yes
    number_sections: yes
    extra_dependencies: subfig
  html_notebook:
    toc: yes
    toc_depth: 2
    toc_float: yes
    number_sections: yes
    df_print: paged
    code_folding: hide
header-includes:
- \usepackage{placeins}
- \usepackage{subfig}
- \usepackage{booktabs}
- extra_dependencies: subfig
subtitle: Dissertation Version
geometry: margin = 0.75in
editor_options:
  markdown:
    wrap: 80
  chunk_output_type: console
---

More details on the protocols followed for building this PARAFAC model can be found in the [StaRdom package vingette](https://cran.r-project.org/web/packages/staRdom/vignettes/PARAFAC_analysis_of_EEM.html)

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE,  
                      warning = FALSE,
                      cache = FALSE,
                      # results = 'hide',
                      dev = "png", 
                      comment = '#>',
                      fig.path = "~/projects/Ch2_DOM/figures/3_PARAFAC/"
                      )

# this essentially places "\FloatBarrier\" at the end of every figure to prevent figures migrating throughout a document
knitr::knit_hooks$set(plot = function(x, options) {
  paste0(knitr::hook_plot_tex(x, options), "\n\\FloatBarrier\n")
})
```

```{r library, include = FALSE, message = FALSE}
librarian::shelf(
  dplyr,
  staRdom,
  knitr,
  gadenbuie/regexplain,
  stringr,
  quiet = TRUE)

```

```{r directory}
setwd("/Users/audreygoeckner/Library/CloudStorage/OneDrive-UniversityofFlorida/Aqualog_processing")

load("./projects/20230915_Goeckner-PGSdata/processed-data/urban-natural_lists-pf1-pf2.rds")
```

```{r global-options}
cores <- parallel::detectCores(logical = TRUE)

options(scipen = 999)

#describe what folder this should be
folder_path <- "./projects/20230915_Goeckner-PGSdata/processed-data"

# Fix this stupid function so it stops printing the figures twice
eempf_compare <- function(pfres, ...) 
{
    p1 <- eempf_fits(pfres, ...)
    p2 <- eempf_plot_comps(pfres, type = 1, ...)
    p3 <- eempf_plot_comps(pfres, type = 2, ...)
    p1 %>% print()
    p2 %>% print()
    p3 %>% print()
    # return(list(p1, p2, p3)) %>% invisible()
}
```

```{r load-data}
#I skipped bc I already ahve it loaded, but there was an error when I tried to load anyways.
eem_list_done <- 
  readRDS("./projects/20230915_Goeckner-PGSdata/processed-data/corrected_eems_2023-11-01.rds")

# eem_list_done <- 
#   eem_range(
#     eem_list_done, 
#     em = c(300, 650)
#   )


#stricly for the purposes of this project, I am creating an eemlist for urban sites and one for natural sites
 eem_list_urban <-
  eem_extract(
    eem_list_done,
    c("Pond01","Pond02","Pond03","Pond04","Pond05","Pond06","Pond07","Pond08","Pond09","Pond10","Pond11","Pond12","Pond13","Pond14","Pond15"),
    keep = TRUE,
    ignore_case = TRUE)
 
  eem_list_natural <-
  eem_extract(
    eem_list_done,
    c("Pond18","Pond19","Pond20","Pond16","Pond17","Pond21"),
    keep = TRUE,
    ignore_case = TRUE)

```

## PARAFAC Model

At a minimum, 50% of the model needs to converge. You can increase the nstart \# to help your model converge.

A_mode = sample loadings 
B_mode = emission loadings 
C_mode = excitation loadings

*note* Fluorophores can have multiple excitation peaks; however, they can only have one emission peak.

### Set Model Parameters

```{r model-params}
#settings for urban
dim_min <- 3 # minimum numbers of components
dim_max <- 7 # maximum numbers of components
nstart <- 50 # number of similar models from which best is chosen
maxit <- 5500 # maximum number of iterations in PARAFAC analysis
ctol <- 10^-5 # tolerance in PARAFAC analysis


#settings for natural
dim_min <- 3 # minimum numbers of components
dim_max <- 7 # maximum numbers of components
nstart <- 100 # number of similar models from which best is chosen
maxit <- 5500 # maximum number of iterations in PARAFAC analysis
ctol <- 10^-6 # tolerance in PARAFAC analysis
```

------------------------------------------------------------------------

## Initial Model - Multiple Component Comparison

```{r model-1, fig.height = 8, fig.width = 8}
#URBAN-------
# Model with non-negative constraints; 
pf1_urban <-
  eem_parafac(eem_list_urban,
              comps = seq(dim_min, dim_max),
              # normalise = FALSE,
              normalise = TRUE,
              const = c("nonneg", "nonneg", "nonneg"),
              maxit = maxit,
              nstart = nstart,
              ctol = ctol,
              cores = cores, 
              output = "all"
              #strictly_converging = TRUE # try increasing nstart first, it's allegedly less resource intensive
              )

# Rescale B and C modes to a maximum fluorescence of 1 for each component
pf1_urban <- lapply(pf1_urban, eempf_rescaleBC, newscale = "Fmax")

#Compare Models
eempf_compare(pf1_urban, contour = TRUE)

#notes: 
#I attempted strictly converging = T, but all model options had double emission peaks, which is a no no. 
#With the current model options, I am leaning toward model 3 (5 components), but some slight double emission peak action going on in comp.5
#--------

#NATURAL-------
# Model with non-negative constraints; 
pf1_natural <-
  eem_parafac(eem_list_natural,
              comps = seq(dim_min, dim_max),
              # normalise = FALSE,
              normalise = TRUE,
              const = c("nonneg", "nonneg", "nonneg"),
              maxit = maxit,
              nstart = nstart,
              ctol = ctol,
              cores = cores, 
              output = "all"
              #strictly_converging = TRUE # try increasing nstart first, it's allegedly less resource intensive
              )

# Rescale B and C modes to a maximum fluorescence of 1 for each component
pf1_natural <- lapply(pf1_natural, eempf_rescaleBC, newscale = "Fmax")

#Compare Models
eempf_compare(pf1_natural, contour = TRUE)

#notes: multiple good options I think. leaning toward models 2-4
#--------

```

### Check Correlations

The PARAFAC algorithm assumes no correlation between the components. If samples are in a wide range of DOC concentrations, a correlation of the components is likely. To avoid that, the samples can be normalized. (From StaRdom webpage)

Later normalization is reversed automatically by multiplying the A modes (sample loadings) with the normalization factors for exports and plots. Reversing normalization can be done manually applying norm2A.

**Normalization here is a logical value dictating whether normalization is undone or not. **

The parameter normalization in eempf_cortable and eempf_corplot is set FALSE (default) if the model quality is to be assessed. _(i.e., don't undo the normalization)_ 

For interpretations and patterns in the actual fluorescence in your samples normalisation has to be set TRUE to see the actual values. _(i.e., undo the normalization)_

```{r check-convergence-m1}
#urban
eempf_convergence(pf1_urban[[1]])
eempf_convergence(pf1_urban[[2]])
eempf_convergence(pf1_urban[[3]]) #I like this model but 42/100 converged models
eempf_convergence(pf1_urban[[4]])
eempf_convergence(pf1_urban[[5]])


#natural
eempf_convergence(pf1_natural[[1]])
eempf_convergence(pf1_natural[[2]])
eempf_convergence(pf1_natural[[3]]) 
eempf_convergence(pf1_natural[[4]])
eempf_convergence(pf1_natural[[5]])
```

```{r component-correlation-model-1}
#URBAN
# eempf_cortable(pf1n_scaled[[4]], normalisation = FALSE)
eempf_corplot(pf1_urban[[1]], progress = FALSE, normalisation = FALSE) # 3-comp model
eempf_corplot(pf1_urban[[2]], progress = FALSE, normalisation = FALSE) # 4-comp model
eempf_corplot(pf1_urban[[3]], progress = FALSE, normalisation = FALSE) # 5-comp model
eempf_corplot(pf1_urban[[4]], progress = FALSE, normalisation = FALSE) # 6-comp model
eempf_corplot(pf1_urban[[5]], progress = FALSE, normalisation = FALSE) # 7-comp model


#NATURAL
# eempf_cortable(pf1n_scaled[[4]], normalisation = FALSE)
eempf_corplot(pf1_natural[[1]], progress = FALSE, normalisation = FALSE) # 3-comp 
eempf_corplot(pf1_natural[[2]], progress = FALSE, normalisation = FALSE) # 4-comp 
eempf_corplot(pf1_natural[[3]], progress = FALSE, normalisation = FALSE) # 5-comp
eempf_corplot(pf1_natural[[4]], progress = FALSE, normalisation = FALSE) # 6-comp 
eempf_corplot(pf1_natural[[5]], progress = FALSE, normalisation = FALSE) # 7-comp 
```

#### Save Output {.unlisted .unnumbered}
```{r save-model-a}
saveRDS(pf1, file = paste0(folder_path, "multi-comp-model_", Sys.Date(), ".rds" ))
```

------------------------------------------------------------------------

## Urban model: Five Component Model

Set Model Parameters
```{r second-model-params}
dim_urban <- 5
nstart <- 25 # number of random starts
ctol <- 10^-8 # decrease tolerance in PARAFAC analysis
maxit = 10000 # increase number of maximum iterations
```

```{r model-2-normalized-data, fig.height = 6, fig.width = 4}

#This step only looks at the 5 component model, which is set by comps = dim_urban, which I previously set to 5
pf2_urban <-
  eem_parafac(eem_list_urban,
              comps = dim_urban,
              normalise = TRUE,
              const = c("nonneg", "nonneg", "nonneg"),
              maxit = maxit,
              nstart = nstart,
              ctol = ctol, 
              output = "all",
              cores = cores ,
              strictly_converging = TRUE
    )

# Re-scale B and C modes (emission and excitation wavelengths) to a maximum fluorescence of 1 for each component so effects are more visible in the plots. The A mode is sample loading
 
pf2_urban <- lapply(pf2_urban, eempf_rescaleBC, newscale = "Fmax")
 
# Compare Models
eempf_compare(pf2_urban, contour = TRUE)
```

Components and Convergence
```{r check-convergence-1}
eempf_convergence(pf2_urban[[1]])
```

```{r component-loadings-1, fig.width = 12, fig.height = 8}
eempf_comp_load_plot(pf2_urban[[1]], contour = TRUE)
```

Check Correlations

normalisation here is a logical value dictating whether normalization is undone or not. 

```{r Check-Correlations-Model-2}
# Setting normalization to FALSE allows us to evaluate the model's accuracy
eempf_cortable(pf2_urban[[1]], normalisation = FALSE)
eempf_corplot(pf2_urban[[1]], progress = FALSE, normalisation = FALSE)

# Setting normalization to TRUE undos normalization and allows us to view patterns in the actual fluorescence
eempf_cortable(pf2_urban[[1]], normalisation = TRUE)
eempf_corplot(pf2_urban[[1]], progress = FALSE, normalisation = TRUE)
```

Find and Exclude Outliers

Leverage of each sample and wavelength will be calculated. The leverage shows to what degree a sample deviates from the average distribution. Samples with high leverage will score closer to 1. If a sample has high leverage, one should determine if there is an analytical issue with the sample. If not, then one should remove the sample from the data set and re-run the PARAFAC model. If the new model is not significantly different than the one including the outlier, than the outlier can remain in the sample set. If the model is quite different, the the sample is too unique and either more samples of this nature are needed or the sample needs to be removed. See [Stedmon, 2008](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lom.2008.6.572) for more details.

```{r m2-outliers, fig.width = 10, fig.height = 6}
# Calculate Leverage
cpl_pf2_urban <- eempf_leverage(pf2_urban[[1]])

# just for viewing
eempf_leverage_plot(cpl_pf2_urban, qlabel = 0.1)

#interacting exclusion plot
exclude_urban_5C <- eempf_leverage_ident(cpl_pf2_urban,qlabel=0.1)

#remove samples selected in exclusion plot
eem_list_urban_ex <- eem_exclude(eem_list_urban, exclude_urban_5C)

#re-run the 5C paraface model with exclusion samples removed
pf2_urban_ex <-
  eem_parafac(eem_list_urban_ex,
              comps = dim_urban,
              normalise = TRUE,
              const = c("nonneg", "nonneg", "nonneg"),
              maxit = maxit,
              nstart = nstart,
              ctol = ctol, 
              output = "all",
              cores = cores ,
              strictly_converging = TRUE
    )

#re check the figures
pf2_urban_ex <- lapply(pf2_urban_ex, eempf_rescaleBC, newscale = "Fmax")
 
# Compare Models
eempf_compare(pf2_urban, contour = TRUE)
```

 Check Residuals

You can also view the residuals of the different samples to see if there are any issues in the model or in the way samples were handled and pre-processed

```{r check-residuals-model-2, fig.width = 10, fig.height = 7}
# Outliers are included to view potential differences in the residuals
pf2_urban_resid <- eempf_residuals(pf2_urban_ex[[1]],
                         eem_list_urban_ex,
                         cores = cores)

# eempf_residuals_plot(pf2[[1]],
#                      eem_list_done,
#                      residuals_only = TRUE,
#                      cores = cores,
#                      contour = TRUE,
#                      spp = 4)

eempf_residuals_metrics(pf2_urban_resid, cpl_pf2_urban)
```

SPLIT-HALF ANALYSIS
```{r sh-all-comps, fig.width = 14, fig.height = 8}
#### SH Analysis Checks Convergence of Model ####

# !! 5 comp !! #
sp_urban <-
  splithalf(
    eem_list_urban,
    comps = 5,
    rand = FALSE,
    normalise = TRUE,
    nstart = 100,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(sp_urban)
splithalf_tcc(sp_urban)

# SH with Randomized Selection
spr4 <-
  splithalf(
    eem_list_done,
    comps = 4,
    rand = TRUE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(spr4)
splithalf_tcc(spr4)

# !! 5 comp !! #
sp5 <-
  splithalf(
    eem_list_done,
    comps = 5,
    rand = FALSE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(sp5)
splithalf_tcc(sp5)

# SH with Randomized Selection
spr5 <-
  splithalf(
    eem_list_done,
    comps = 5,
    rand = TRUE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(spr5)
splithalf_tcc(spr5)

# !! 6 comp !! #
sp6 <-
  splithalf(
    eem_list_done,
    comps = 6,
    rand = FALSE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(sp6)
splithalf_tcc(sp6)

# SH with Randomized Selection
spr6 <-
  splithalf(
    eem_list_done,
    comps = 6,
    rand = TRUE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(spr6)
splithalf_tcc(spr6)
```


## Natural Five Component Model

 Set Model Parameters
```{r third-model-params}
dim_natural1 <- 5
nstart <- 25 # number of random starts
ctol <- 10^-8 # decrease tolerance in PARAFAC analysis
maxit = 10000 # increase number of maximum iterations
```

```{r model-3-normalized-data, fig.height = 8, fig.width = 4}
pf2_natural5 <-
  eem_parafac(eem_list_natural,
              comps = dim_natural1,
              normalise = TRUE,
              const = c("nonneg", "nonneg", "nonneg"),
              maxit = maxit,
              nstart = nstart,
              ctol = ctol, 
              output = "all",
              cores = cores,
              strictly_converging = TRUE
              )

# Re-scale B and C modes (emission and excitation wavelengths) to a maximum fluorescence of 1 for each component so effects are more visible in the plots. The A mode is sample loading
 
pf2_natural5 <- lapply(pf2_natural5, eempf_rescaleBC, newscale = "Fmax")
 
# Compare Models
eempf_compare(pf2_natural5, contour = TRUE)
```

Components and Convergence
```{r check-convergence-3}
eempf_convergence(pf2_natural5[[1]])
```

```{r component-loadings-3, fig.width = 10, fig.height = 6}
eempf_comp_load_plot(pf2_natural5[[1]], contour = TRUE)
```

Check Correlations

normalisation here is a logical value dictating whether normalization is undone or not. 

```{r Check-Correlations-Model-3}
# Setting normalization to FALSE allows us to evaluate the model's accuracy
eempf_cortable(pf2_natural5[[1]], normalisation = FALSE)
eempf_corplot(pf2_natural5[[1]], progress = FALSE, normalisation = FALSE)

# Setting normalization to TRUE undos normalization and allows us to view patterns in the actual fluorescence
eempf_cortable(pf2_natural5[[1]], normalisation = TRUE)
eempf_corplot(pf2_natural5[[1]], progress = FALSE, normalisation = TRUE)
```

Find and Exclude Outliers

Leverage of each sample and wavelength will be calculated. The leverage shows to what degree a sample deviates from the average distribution. Samples with high leverage will score closer to 1. If a sample has high leverage, one should determine if there is an analytical issue with the sample. If not, then one should remove the sample from the data set and re-run the PARAFAC model. If the new model is not significantly different than the one including the outlier, than the outlier can remain in the sample set. If the model is quite different, the the sample is too unique and either more samples of this nature are needed or the sample needs to be removed. See [Stedmon, 2008](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lom.2008.6.572) for more details.

```{r m5-outliers, fig.width = 10, fig.height = 6}
# Calculate Leverage
cpl_pf2_natural5 <- eempf_leverage(pf2_natural5[[1]])

# just for viewing
eempf_leverage_plot(cpl_pf2_natural5, qlabel = 0.1)

#interacting exclusion plot
exclude_natural_5C <- eempf_leverage_ident(cpl_pf2_natural5,qlabel=0.1)

#remove samples selected in exclusion plot
eem_list_natural_ex <- eem_exclude(eem_list_natural, exclude_natural_5C)

#re-run the 5C paraface model with exclusion samples removed
pf2_natural5_ex <-
  eem_parafac(eem_list_natural_ex,
              comps = dim_natural1,
              normalise = TRUE,
              const = c("nonneg", "nonneg", "nonneg"),
              maxit = maxit,
              nstart = nstart,
              ctol = ctol, 
              output = "all",
              cores = cores ,
              strictly_converging = TRUE
    )

#re check the figures
pf2_urban_ex <- lapply(pf2_urban_ex, eempf_rescaleBC, newscale = "Fmax")
 
# Compare Models
eempf_compare(pf2_urban, contour = TRUE)
```

Check Residuals

You can also view the residuals of the different samples to see if there are any issues in the model or in the way samples were handled and pre-processed

```{r check-residuals-model-3, fig.width = 10, fig.height = 8}
# Outliers are included to view potential differences in the residuals
pf5_resid <- eempf_residuals(pf5[[1]],
                         eem_list_done,
                         cores = cores)

eempf_residuals_plot(pf5[[1]],
                     eem_list_done,
                     select = eem_names(eem_list_done)[10:25],
                     residuals_only = TRUE,
                     cores = cores,
                     contour = TRUE,
                     spp = 5)

eempf_residuals_metrics(pf5_resid, cpl_pf5)
```

SPLIT-HALF ANALYSIS
```{r sh-all-comps, fig.width = 14, fig.height = 8}
#### SH Analysis Checks Convergence of Model ####

# !! 5 comp !! #
sp_natural5 <-
  splithalf(
    eem_list_natural,
    comps = 5,
    rand = FALSE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(sp_natural5)
splithalf_tcc(sp_natural5)

# SH with Randomized Selection
spr4 <-
  splithalf(
    eem_list_done,
    comps = 4,
    rand = TRUE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(spr4)
splithalf_tcc(spr4)

# !! 5 comp !! #
sp5 <-
  splithalf(
    eem_list_done,
    comps = 5,
    rand = FALSE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(sp5)
splithalf_tcc(sp5)

# SH with Randomized Selection
spr5 <-
  splithalf(
    eem_list_done,
    comps = 5,
    rand = TRUE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(spr5)
splithalf_tcc(spr5)

# !! 6 comp !! #
sp6 <-
  splithalf(
    eem_list_done,
    comps = 6,
    rand = FALSE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(sp6)
splithalf_tcc(sp6)

# SH with Randomized Selection
spr6 <-
  splithalf(
    eem_list_done,
    comps = 6,
    rand = TRUE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(spr6)
splithalf_tcc(spr6)
```

```{r save-split-half-comparisons}
save(list = c("sp4", "sp5", "sp6", "spr4", "spr5", "spr6"), 
     file = paste0(folder_path, "split-half-comparisons_", Sys.Date(), ".RData"))
```


------------------------------------------------------------------------






Rename model components
```{r set-model-component-names}
# set new model names, number of models must be equal to number of names

eempf_comp_names(pf2_natural5) <- c("Nat C1","Nat C2","Nat C3","Nat C4","Nat C5")
eempf_comp_names(pf2_urban) <- c("SWP C1","SWP C2","SWP C3","SWP C4","SWP C5")

```

Component model plot for pres
```{r}
eempf_compare(pf2_natural5, contour = TRUE)

ggeem(pf2_urban[[1]], contour = TRUE)
ggeem(pf2_natural5[[1]], contour = TRUE)
```

putting all samples in? 
```{r}
#pf3n_wOutliers <- A_missing(eem_list_dil, pfmodel = pf3n_hightole[[1]], cores = cores)

all_in_urban <- A_missing(eem_list = eem_list_done, pfmodel = pf2_urban[[1]],cores = cores)
all_in_urban
write.csv(all_in_urban$A,"./projects/20230915_Goeckner-PGSdata/processed-data/Urban_Model_compLoadings.csv")

all_in_natural <- A_missing(eem_list = eem_list_done, pfmodel = pf2_natural5[[1]],cores = cores)
all_in_natural
write.csv(all_in_natural$A,"./projects/20230915_Goeckner-PGSdata/processed-data/Natural_Model_compLoadings.csv")


```

component importance
```{r comp-importance}

#The derived values state the loss in model fit if one component is not used in the modeling process.

#urban
(eempf_varimp(pf2_urban[[1]], 
             eem_list_done, 
             cores = cores))
#[1] 0.10412922 0.04380087 0.04568787 0.03390315 0.02650978

#natural
(eempf_varimp(pf2_natural5[[1]], 
             eem_list_done, 
             cores = cores))
#[1] 0.07704256 0.08933428 0.04946626 0.01077085 0.01284478
```

Urban residuals - what was not explained? 
```{r check-residuals-model-3, fig.width = 10, fig.height = 8}
#You can also view the residuals of the different samples to see if there are any issues in the model or in the way samples were handled and pre-processed

# Outliers are included to view potential differences in the residuals
pf2_urban_resids <- eempf_residuals(pf2_urban[[1]],
                         eem_list_done,
                         cores = cores)

eempf_residuals_plot(pf2_urban[[1]],
                     eem_list_done,
                     select = eem_names(eem_list_done)[10:25],
                     residuals_only = TRUE,
                     cores = cores,
                     contour = TRUE,
                     spp = 5)

eempf_residuals_metrics(pf2_urban_resids, cpl_pf2_urban)

#vignette example
residuals_urban <- eempf_residuals(pf2_urban[[1]], eem_list_done, cores = 2)
leverage_urban <- eempf_leverage(pf2_urban[[1]])
metrics_urban <- eempf_residuals_metrics(residuals, leverage)

#urban figure
lapply(names(metrics_urban), function(name){
metrics[[name]] %>%
mutate(mode = name, element = !!sym(name))
}) %>%
bind_rows() %>%
pivot_longer(cols = RSS:LEV, names_to = "metric", values_to = "value") %>%
# uncomment the following line to select certain metrics
# filter(metric %in% c("RSS","LEV")) %>%
ggplot(aes(x = element, y = value, colour = metric))+
geom_point()+
facet_wrap(mode ~ ., ncol = 3, scales = "free")+
theme(axis.text.x = element_text(angle = 90))+
scale_y_continuous(trans="log")
```

Natural residuals - what was not explained? 
```{r check-residuals-model-3, fig.width = 10, fig.height = 8}
#You can also view the residuals of the different samples to see if there are any issues in the model or in the way samples were handled and pre-processed

# Outliers are included to view potential differences in the residuals
pf2_urban_resids <- eempf_residuals(pf2_urban[[1]],
                         eem_list_done,
                         cores = cores)

eempf_residuals_plot(pf2_urban[[1]],
                     eem_list_done,
                     select = eem_names(eem_list_done)[10:25],
                     residuals_only = TRUE,
                     cores = cores,
                     contour = TRUE,
                     spp = 5)

eempf_residuals_metrics(pf2_urban_resids, cpl_pf2_urban)

#vignette example
residuals_natural <- eempf_residuals(pf2_natural5[[1]], eem_list_done, cores = cores)
leverage_natural <- eempf_leverage(pf2_natural5[[1]])
metrics_natural <- eempf_residuals_metrics(residuals_natural, leverage_natural)

#urban figure
lapply(names(metrics_natural), function(name){
metrics_natural[[name]] %>%
mutate(mode = name, element = !!sym(name))
}) %>%
bind_rows() %>%
pivot_longer(cols = RSS:LEV, names_to = "metric", values_to = "value") %>%
# uncomment the following line to select certain metrics
# filter(metric %in% c("RSS","LEV")) %>%
ggplot(aes(x = element, y = value, colour = metric))+
geom_point()+
facet_wrap(mode ~ ., ncol = 3, scales = "free")+
theme(axis.text.x = element_text(angle = 90))+
scale_y_continuous(trans="log")
```


# Final Model

#### Re-Set Model Parameters

```{r final-model-params}
dim <- 5 # numbers of model components
nstart <- 50 # number of similar models from which best is chosen
maxit <- 20000 # maximum number of iterations in PARAFAC analysis
ctol <- 10^-10 # tolerance in PARAFAC analysis
```

```{r run-final-model, fig.height = 8, fig.width = 5}
pf_final <- 
  eem_parafac(eem_list_done, 
              comps = dim, 
              normalise = TRUE, 
              const = c("nonneg", "nonneg", "nonneg"), 
              maxit = maxit, 
              nstart = nstart, 
              ctol = ctol, 
              output = "all", 
              cores = cores)

pf_final <- lapply(pf_final, eempf_rescaleBC, newscale = "Fmax")

# Compare Models
eempf_compare(pf_final, contour = TRUE)

eempf_corplot(pf_final[[1]], progress = FALSE, normalisation = FALSE)
# Setting normalization to TRUE allows us to view patterns in the actual fluorescence
eempf_corplot(pf_final[[1]], progress = FALSE, normalisation = TRUE)
```
### Components and Convergence
```{r check-convergence}
eempf_convergence(pf_final[[1]])
```

```{r component-loadings, fig.width = 12, fig.height = 8}
eempf_comp_load_plot(pf_final[[1]], contour = TRUE)
```

```{r}
eempf_comps3D(pf_final[[1]])
```

### Check Residuals

```{r final-model-residuals, fig.width = 10, fig.height = 8}
eempf_residuals_plot(pf_final[[1]],
                     eem_list_done,
                     residuals_only = FALSE,
                     cores = cores,
                     contour = TRUE)

resid <- eempf_residuals(pf_final[[1]], 
                         eem_list_done, 
                         cores = cores)

# If any outliers were removed, they are added back in to view potential differences in the residuals
cpl_all <- eempf_leverage(pf_final[[1]])

(redmet <- eempf_residuals_metrics(resid, cpl_all))
```

#### Split-Half Analysis

```{r Split-Half}
#### SH Analysis Checks Convergence of Model ####
sp <-
  splithalf(
    eem_list_done,
    comps = 5,
    rand = FALSE,
    normalise = TRUE,
    nstart = 20,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 2500,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(sp)
splithalf_tcc(sp)

# SH with Randomized Selection
spr <-
  splithalf(
    eem_list_done,
    comps = 5,
    rand = TRUE,
    normalise = TRUE,
    nstart = 20,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 2500,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(spr)
splithalf_tcc(spr)
```

### Final Model Checks

#### Core Consistency

```{r core-consistency}
eempf_corcondia(pf_final[[1]], 
                eem_list_done)
```

#### EEMqual

```{r EEMqual}
eempf_eemqual(pf_final[[1]], 
              eem_list_done, 
              spr, 
              cores = cores)
```

#### Component Importance

```{r comp-importance}
(eempf_varimp(pf_final[[1]], 
             eem_list_done, 
             cores = cores))
```

#### Shift and Shape Sensitive Congruence Coefficient

```{r scc-final-model}
ssccheck <- eempf_ssccheck(pf_final[[1]]$models, best = 3, cores = cores) # best 3 models are shown

eempf_plot_ssccheck(ssccheck)
```

------------------------------------------------------------------------

## Model Output

Some of these reports are a little redundant to the 4_get-peaks-and-slopes R code. 

```{r save-PARAFAC-model}
saveRDS(pf_final, file = paste0(folder_path, dim, "-comp-final-model_", Sys.Date(), ".rds" ))
```

```{r set-model-component-names}
# set new model names, number of models must be equal to number of names
eempf_comp_names(pf_final) <- c("C1","C2","C3","C4","C5")
```

```{r create-model-report}
absorbance <- absorbance_read("~/projects/Ch2_DOM/processed-data/abs-for-analysis", recursive = T, cores = cores)
absorbance <- abs_blcor(absorbance, wlrange = c(680, 700))

eempf_report(pf_final[[1]], 
             export = paste0("~/projects/Ch2_DOM/output/ch2_parafac_report_", Sys.Date(), ".html"), 
             eem_list = eem_list_done, 
             absorbance = absorbance,
             shmodel = sp, 
             performance = TRUE, 
             residuals = TRUE)
```

```{r save-components-and-operfluor}
# component breakdown 
factor_table <- 
  eempf_export(pf_final[[1]], Fmax = TRUE) %>%
  readr::write_csv(paste0("~/projects/Ch2_DOM/output/ch2_PARAFAC-model-results_", Sys.Date(), ".csv"))

# OpenFluor report
eempf_openfluor(pf_final[[1]], file = paste0("~/projects/Ch2_DOM/output/ch2_PARAFAC_openfluor_", Sys.Date(), ".txt"))
```

```{r parafac-index-abs-report}
eempf_analysis <- 
  eempf4analysis(
  pf_final[[1]],
  eem_list = eem_list_done,
  absorbance = absorbance,
  cuvl = 1,
  n = 5,
  export = NULL,
  cores = parallel::detectCores(logical = FALSE)
)
```

```{r rename-samples}
eempf_analysis$sampleid <-
  str_extract(eempf_analysis$sample, "([B]\\d+S\\d{1,2})")

eempf_analysis$site <-
  str_extract(eempf_analysis$sample, "(Blank1|Blank2|Blank3|Blank4|Blank5|HAT|HOGDN|HOGUP|POS|SWBUP|SWB|TUM)")

eempf_analysis$date <- 
  str_extract(eempf_analysis$sample, "(?<=_)(\\d{4})[[:alpha:]]\\w+\\d{2}")
  
eempf_analysis$dilution <- 
  str_extract(eempf_analysis$sample, "(dil+\\d{1})")

eempf_analysis$date <-  lubridate::ymd(eempf_analysis$date)

eempf_analysis
```


```{r export-peaks-indicies-and-comps}
readr::write_csv(eempf_analysis, paste0("~/projects/Ch2_DOM/output/ch2_full-report_", Sys.Date(), ".csv"))
```

