---
title: "PARAFAC Model Template"
author: "Emily Taylor"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_depth: '2'
    df_print: paged
  pdf_document:
    fig_crop: yes
    toc: yes
    number_sections: yes
    extra_dependencies: subfig
  html_notebook:
    toc: yes
    toc_depth: 2
    toc_float: yes
    number_sections: yes
    df_print: paged
    code_folding: hide
header-includes:
- \usepackage{placeins}
- \usepackage{subfig}
- \usepackage{booktabs}
- extra_dependencies: subfig
subtitle: Dissertation Version
geometry: margin = 0.75in
editor_options:
  markdown:
    wrap: 80
---

More details on the protocols followed for building this PARAFAC model can be found in the [StaRdom package vingette](https://cran.r-project.org/web/packages/staRdom/vignettes/PARAFAC_analysis_of_EEM.html)

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE,  
                      warning = FALSE,
                      cache = FALSE,
                      # results = 'hide',
                      dev = "png", 
                      comment = '#>',
                      fig.path = "~/projects/Ch2_DOM/figures/3_PARAFAC/"
                      )

# this essentially places "\FloatBarrier\" at the end of every figure to prevent figures migrating throughout a document
knitr::knit_hooks$set(plot = function(x, options) {
  paste0(knitr::hook_plot_tex(x, options), "\n\\FloatBarrier\n")
})
```

```{r library, include = FALSE, message = FALSE}
librarian::shelf(
  dplyr,
  staRdom,
  knitr,
  gadenbuie/regexplain,
  stringr,
  quiet = TRUE)

```

```{r global-options}
cores <- parallel::detectCores(logical = TRUE)

options(scipen = 999)

folder_path <- "~/projects/Ch2_DOM/output/"

# Fix this stupid function so it stops printing the figures twice
eempf_compare <- function(pfres, ...) 
{
    p1 <- eempf_fits(pfres, ...)
    p2 <- eempf_plot_comps(pfres, type = 1, ...)
    p3 <- eempf_plot_comps(pfres, type = 2, ...)
    p1 %>% print()
    p2 %>% print()
    p3 %>% print()
    # return(list(p1, p2, p3)) %>% invisible()
}
```

```{r load-data}
eem_list_done <- 
  readRDS("~/projects/Ch2_DOM/output/corrected-eems_ 20230711.rds")

# eem_list_done <- 
#   eem_range(
#     eem_list_done, 
#     em = c(300, 650)
#   )
```

## PARAFAC Model

At a minimum, 50% of the model needs to converge. You can increase the nstart \# to help your model converge.

A_mode = sample loadings 
B_mode = emission loadings 
C_mode = excitation loadings

*note* Fluorophores can have multiple excitation peaks; however, they can only have one emission peak.

### Set Model Parameters

```{r model-params}
dim_min <- 4 # minimum numbers of components
dim_max <- 8 # maximum numbers of components
nstart <- 100 # number of similar models from which best is chosen
maxit <- 5000 # maximum number of iterations in PARAFAC analysis
ctol <- 10^-6 # tolerance in PARAFAC analysis
```

------------------------------------------------------------------------

## Initial Model - Multiple Component Comparison

```{r model-1, fig.height = 8, fig.width = 8}
# Model with non-negative constraints; 
pf1 <-
  eem_parafac(eem_list_done,
              comps = seq(dim_min, dim_max),
              # normalise = FALSE,
              normalise = TRUE,
              const = c("nonneg", "nonneg", "nonneg"),
              maxit = maxit,
              nstart = nstart,
              ctol = ctol,
              cores = cores, 
              output = "all"
              # strictly_converging = TRUE # try increasing nstart first, it's allegedly less resource intensive
              )

##### Rescale B and C modes to a maximum fluorescence of 1 for each component ####
pf1 <- lapply(pf1, eempf_rescaleBC, newscale = "Fmax")

#### Compare Models ####
eempf_compare(pf1, contour = TRUE)
```

### Check Correlations

The PARAFAC algorithm assumes no correlation between the components. If samples are in a wide range of DOC concentrations, a correlation of the components is likely. To avoid that, the samples can be normalized. (From StaRdom webpage)

Later normalization is reversed automatically by multiplying the A modes (sample loadings) with the normalization factors for exports and plots. Reversing normalization can be done manually applying norm2A.

**Normalization here is a logical value dictating whether normalization is undone or not. **

The parameter normalization in eempf_cortable and eempf_corplot is set FALSE (default) if the model quality is to be assessed. _(i.e., don't undo the normalization)_ 

For interpretations and patterns in the actual fluorescence in your samples normalisation has to be set TRUE to see the actual values. _(i.e., undo the normalization)_

```{r check-convergence-m1}
eempf_convergence(pf1[[1]])
eempf_convergence(pf1[[2]])
eempf_convergence(pf1[[3]])
eempf_convergence(pf1[[4]])
eempf_convergence(pf1[[5]])
```

```{r component-correlation-model-1}
# eempf_cortable(pf1n_scaled[[4]], normalisation = FALSE)
eempf_corplot(pf1[[1]], progress = FALSE, normalisation = FALSE) # 3-comp model
eempf_corplot(pf1[[2]], progress = FALSE, normalisation = FALSE) # 4-comp model
eempf_corplot(pf1[[3]], progress = FALSE, normalisation = FALSE) # 5-comp model
eempf_corplot(pf1[[4]], progress = FALSE, normalisation = FALSE) # 6-comp model
eempf_corplot(pf1[[5]], progress = FALSE, normalisation = FALSE) # 7-comp model
```

#### Save Output {.unlisted .unnumbered}
```{r save-model-a}
saveRDS(pf1, file = paste0(folder_path, "multi-comp-model_", Sys.Date(), ".rds" ))
```

------------------------------------------------------------------------

#### Remove Unneeded Objects {.unlisted .unnumbered}

```{r m0-clean-up-PARAFAC}
rm(list = setdiff(ls(), c("eem_list_done", "cores", "eempf_compare", "folder_path")))
gc(verbose = FALSE, full = TRUE)
```

## Four Component Model

### Set Model Parameters
```{r second-model-params}
dim <- 4
nstart <- 25 # number of random starts
ctol <- 10^-8 # decrease tolerance in PARAFAC analysis
maxit = 10000 # increase number of maximum iterations
```

```{r model-2-normalized-data, fig.height = 6, fig.width = 4}
pf2 <-
  eem_parafac(eem_list_done,
              comps = dim,
              normalise = TRUE,
              const = c("nonneg", "nonneg", "nonneg"),
              maxit = maxit,
              nstart = nstart,
              ctol = ctol, 
              output = "all",
              cores = cores ,
              strictly_converging = TRUE
    )

# Re-scale B and C modes (emission and excitation wavelengths) to a maximum fluorescence of 1 for each component so effects are more visible in the plots. The A mode is sample loading
 
pf2 <- lapply(pf2, eempf_rescaleBC, newscale = "Fmax")
 
# Compare Models
eempf_compare(pf2, contour = TRUE)
```

### Components and Convergence
```{r check-convergence-1}
eempf_convergence(pf2[[1]])
```

```{r component-loadings-1, fig.width = 12, fig.height = 8}
eempf_comp_load_plot(pf2[[1]], contour = TRUE)
```

#### Check Correlations

normalisation here is a logical value dictating whether normalization is undone or not. 

```{r Check-Correlations-Model-2}
# Setting normalization to FALSE allows us to evaluate the model's accuracy
eempf_cortable(pf2[[1]], normalisation = FALSE)
eempf_corplot(pf2[[1]], progress = FALSE, normalisation = FALSE)

# Setting normalization to TRUE undos normalization and allows us to view patterns in the actual fluorescence
eempf_cortable(pf2[[1]], normalisation = TRUE)
eempf_corplot(pf2[[1]], progress = FALSE, normalisation = TRUE)
```

#### Find and Exclude Outliers

Leverage of each sample and wavelength will be calculated. The leverage shows to what degree a sample deviates from the average distribution. Samples with high leverage will score closer to 1. If a sample has high leverage, one should determine if there is an analytical issue with the sample. If not, then one should remove the sample from the data set and re-run the PARAFAC model. If the new model is not significantly different than the one including the outlier, than the outlier can remain in the sample set. If the model is quite different, the the sample is too unique and either more samples of this nature are needed or the sample needs to be removed. See [Stedmon, 2008](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lom.2008.6.572) for more details.

```{r m2-outliers, fig.width = 10, fig.height = 6}
# Calculate Leverage
cpl_pf2 <- eempf_leverage(pf2[[1]])

eempf_leverage_plot(cpl_pf2, qlabel = 0.1)

```

#### Check Residuals

You can also view the residuals of the different samples to see if there are any issues in the model or in the way samples were handled and pre-processed

```{r check-residuals-model-2, fig.width = 10, fig.height = 7}
# Outliers are included to view potential differences in the residuals
pf2_resid <- eempf_residuals(pf2[[1]],
                         eem_list_done,
                         cores = cores)

# eempf_residuals_plot(pf2[[1]],
#                      eem_list_done,
#                      residuals_only = TRUE,
#                      cores = cores,
#                      contour = TRUE,
#                      spp = 4)

eempf_residuals_metrics(pf2_resid, cpl_pf2n)
```

#### Save Output {.unlisted .unnumbered}

```{r save-model}
saveRDS(pf2, file = paste0(folder_path, dim, "-comp-model_", Sys.Date(), ".rds" ))
```

------------------------------------------------------------------------

#### Remove Unneeded Objects {.unlisted .unnumbered}

```{r m4-clean-up-PARAFAC}
rm(list = setdiff(ls(), c("eem_list_done", "cores", "eempf_compare", "folder_path")))
gc(verbose = FALSE, full = TRUE)
```

## Five Component Model

### Set Model Parameters
```{r third-model-params}
dim <- 5
nstart <- 25 # number of random starts
ctol <- 10^-8 # decrease tolerance in PARAFAC analysis
maxit = 10000 # increase number of maximum iterations
```

```{r model-3-normalized-data, fig.height = 8, fig.width = 4}
pf5 <-
  eem_parafac(eem_list_done,
              comps = dim,
              normalise = TRUE,
              const = c("nonneg", "nonneg", "nonneg"),
              maxit = maxit,
              nstart = nstart,
              ctol = ctol, 
              output = "all",
              cores = cores,
              strictly_converging = TRUE
              )

# Re-scale B and C modes (emission and excitation wavelengths) to a maximum fluorescence of 1 for each component so effects are more visible in the plots. The A mode is sample loading
 
pf5 <- lapply(pf5, eempf_rescaleBC, newscale = "Fmax")
 
# Compare Models
eempf_compare(pf5, contour = TRUE)
```

### Components and Convergence
```{r check-convergence-3}
eempf_convergence(pf5[[1]])
```

```{r component-loadings-3, fig.width = 10, fig.height = 6}
eempf_comp_load_plot(pf5[[1]], contour = TRUE)
```

#### Check Correlations

normalisation here is a logical value dictating whether normalization is undone or not. 

```{r Check-Correlations-Model-3}
# Setting normalization to FALSE allows us to evaluate the model's accuracy
eempf_cortable(pf5[[1]], normalisation = FALSE)
eempf_corplot(pf5[[1]], progress = FALSE, normalisation = FALSE)

# Setting normalization to TRUE undos normalization and allows us to view patterns in the actual fluorescence
eempf_cortable(pf5[[1]], normalisation = TRUE)
eempf_corplot(pf5[[1]], progress = FALSE, normalisation = TRUE)
```

#### Find and Exclude Outliers

Leverage of each sample and wavelength will be calculated. The leverage shows to what degree a sample deviates from the average distribution. Samples with high leverage will score closer to 1. If a sample has high leverage, one should determine if there is an analytical issue with the sample. If not, then one should remove the sample from the data set and re-run the PARAFAC model. If the new model is not significantly different than the one including the outlier, than the outlier can remain in the sample set. If the model is quite different, the the sample is too unique and either more samples of this nature are needed or the sample needs to be removed. See [Stedmon, 2008](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lom.2008.6.572) for more details.

```{r m5-outliers, fig.width = 10, fig.height = 6}
# Calculate Leverage
cpl_pf5 <- eempf_leverage(pf5[[1]])

eempf_leverage_plot(cpl_pf5, qlabel = 0.1)

```

#### Check Residuals

You can also view the residuals of the different samples to see if there are any issues in the model or in the way samples were handled and pre-processed

```{r check-residuals-model-3, fig.width = 10, fig.height = 8}
# Outliers are included to view potential differences in the residuals
pf5_resid <- eempf_residuals(pf5[[1]],
                         eem_list_done,
                         cores = cores)

eempf_residuals_plot(pf5[[1]],
                     eem_list_done,
                     select = eem_names(eem_list_done)[10:25],
                     residuals_only = TRUE,
                     cores = cores,
                     contour = TRUE,
                     spp = 5)

eempf_residuals_metrics(pf5_resid, cpl_pf5)
```

#### Save Output

```{r save-model-5}
saveRDS(pf5, file = paste0(folder_path, dim, "-comp-model_", Sys.Date(), ".rds" ))
```

------------------------------------------------------------------------

#### Remove Unneeded Objects {.unlisted .unnumbered}

```{r m5-clean-up-PARAFAC}
rm(list = setdiff(ls(), c("eem_list_done", "cores", "eempf_compare", "folder_path")))
gc(verbose = FALSE, full = TRUE)
```

## Six Component Model

### Set Model Parameters
```{r fourth-model-params}
dim <- 6
nstart <- 25 # number of random starts
ctol <- 10^-8 # decrease tolerance in PARAFAC analysis
maxit = 10000 # increase number of maximum iterations
```

```{r model-4-normalized-data, fig.height = 8, fig.width = 4}
pf6 <-
  eem_parafac(eem_list_done,
              comps = dim,
              normalise = TRUE,
              const = c("nonneg", "nonneg", "nonneg"),
              maxit = maxit,
              nstart = nstart,
              ctol = ctol, 
              output = "all",
              cores = cores,
              strictly_converging = TRUE
              )

# Re-scale B and C modes (emission and excitation wavelengths) to a maximum fluorescence of 1 for each component so effects are more visible in the plots. The A mode is sample loading
 
pf6 <- lapply(pf6, eempf_rescaleBC, newscale = "Fmax")
 
# Compare Models
eempf_compare(pf6, contour = TRUE)
```

### Components and Convergence
```{r check-convergence-4}
eempf_convergence(pf6[[1]])
```

```{r component-loadings-4, fig.width = 8, fig.height = 6}
eempf_comp_load_plot(pf6[[1]], contour = TRUE)
```

#### Check Correlations

normalisation here is a logical value dictating whether normalization is undone or not. 

```{r Check-Correlations-Model-4}
# Setting normalization to FALSE allows us to evaluate the model's accuracy
eempf_cortable(pf6[[1]], normalisation = FALSE)
eempf_corplot(pf6[[1]], progress = FALSE, normalisation = FALSE)

# Setting normalization to TRUE undos normalization and allows us to view patterns in the actual fluorescence
eempf_cortable(pf6[[1]], normalisation = TRUE)
eempf_corplot(pf6[[1]], progress = FALSE, normalisation = TRUE)
```

#### Find and Exclude Outliers

Leverage of each sample and wavelength will be calculated. The leverage shows to what degree a sample deviates from the average distribution. Samples with high leverage will score closer to 1. If a sample has high leverage, one should determine if there is an analytical issue with the sample. If not, then one should remove the sample from the data set and re-run the PARAFAC model. If the new model is not significantly different than the one including the outlier, than the outlier can remain in the sample set. If the model is quite different, the the sample is too unique and either more samples of this nature are needed or the sample needs to be removed. See [Stedmon, 2008](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lom.2008.6.572) for more details.

```{r m6-outliers, fig.width = 10, fig.height = 6}
# Calculate Leverage
cpl_pf6 <- eempf_leverage(pf6[[1]])

eempf_leverage_plot(cpl_pf6, qlabel = 0.1)

```

#### Check Residuals

You can also view the residuals of the different samples to see if there are any issues in the model or in the way samples were handled and pre-processed

```{r check-residuals-model-4, fig.width = 10, fig.height = 8}
# Outliers are included to view potential differences in the residuals
pf6_resid <- eempf_residuals(pf6[[1]],
                         eem_list_done,
                         cores = cores)

# eempf_residuals_plot(pf6[[1]],
#                      eem_list_done,
#                      residuals_only = TRUE,
#                      cores = cores,
#                      contour = TRUE,
#                      spp = 6)

eempf_residuals_metrics(pf6_resid, cpl_pf6)
```

#### Save Output

```{r save-model-6}
saveRDS(pf6, file = paste0(folder_path, dim, "-comp-model_", Sys.Date(), ".rds" ))
```

------------------------------------------------------------------------
#### Remove Unneeded Objects {.unlisted .unnumbered}

```{r m3-clean-up-PARAFAC}
rm(list = setdiff(ls(), c("eem_list_done", "cores", "eempf_compare", "folder_path")))
gc(verbose = FALSE, full = TRUE)
```

# Spilt Half 

```{r sh-all-comps, fig.width = 14, fig.height = 8}
#### SH Analysis Checks Convergence of Model ####

# !! 4 comp !! #
sp4 <-
  splithalf(
    eem_list_done,
    comps = 4,
    rand = FALSE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(sp4)
splithalf_tcc(sp4)

# SH with Randomized Selection
spr4 <-
  splithalf(
    eem_list_done,
    comps = 4,
    rand = TRUE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(spr4)
splithalf_tcc(spr4)

# !! 5 comp !! #
sp5 <-
  splithalf(
    eem_list_done,
    comps = 5,
    rand = FALSE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(sp5)
splithalf_tcc(sp5)

# SH with Randomized Selection
spr5 <-
  splithalf(
    eem_list_done,
    comps = 5,
    rand = TRUE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(spr5)
splithalf_tcc(spr5)

# !! 6 comp !! #
sp6 <-
  splithalf(
    eem_list_done,
    comps = 6,
    rand = FALSE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(sp6)
splithalf_tcc(sp6)

# SH with Randomized Selection
spr6 <-
  splithalf(
    eem_list_done,
    comps = 6,
    rand = TRUE,
    normalise = TRUE,
    nstart = 200,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 20000,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(spr6)
splithalf_tcc(spr6)
```

```{r save-split-half-comparisons}
save(list = c("sp4", "sp5", "sp6", "spr4", "spr5", "spr6"), 
     file = paste0(folder_path, "split-half-comparisons_", Sys.Date(), ".RData"))
```

### Remove Unneeded Objects

```{r clean-up-PARAFAC}
rm(list = setdiff(ls(), c("eem_list_done", "cores", "eempf_compare", "folder_path")))
gc(verbose = FALSE, full = TRUE)
```

------------------------------------------------------------------------

------------------------------------------------------------------------

# Final Model

#### Re-Set Model Parameters

```{r final-model-params}
dim <- 5 # numbers of model components
nstart <- 50 # number of similar models from which best is chosen
maxit <- 20000 # maximum number of iterations in PARAFAC analysis
ctol <- 10^-10 # tolerance in PARAFAC analysis
```

```{r run-final-model, fig.height = 8, fig.width = 5}
pf_final <- 
  eem_parafac(eem_list_done, 
              comps = dim, 
              normalise = TRUE, 
              const = c("nonneg", "nonneg", "nonneg"), 
              maxit = maxit, 
              nstart = nstart, 
              ctol = ctol, 
              output = "all", 
              cores = cores)

pf_final <- lapply(pf_final, eempf_rescaleBC, newscale = "Fmax")

# Compare Models
eempf_compare(pf_final, contour = TRUE)

eempf_corplot(pf_final[[1]], progress = FALSE, normalisation = FALSE)
# Setting normalization to TRUE allows us to view patterns in the actual fluorescence
eempf_corplot(pf_final[[1]], progress = FALSE, normalisation = TRUE)
```
### Components and Convergence
```{r check-convergence}
eempf_convergence(pf_final[[1]])
```

```{r component-loadings, fig.width = 12, fig.height = 8}
eempf_comp_load_plot(pf_final[[1]], contour = TRUE)
```

```{r}
eempf_comps3D(pf_final[[1]])
```

#### Check Residuals

```{r final-model-residuals, fig.width = 10, fig.height = 8}
eempf_residuals_plot(pf_final[[1]],
                     eem_list_done,
                     residuals_only = FALSE,
                     cores = cores,
                     contour = TRUE)

resid <- eempf_residuals(pf_final[[1]], 
                         eem_list_done, 
                         cores = cores)

# If any outliers were removed, they are added back in to view potential differences in the residuals
cpl_all <- eempf_leverage(pf_final[[1]])

(redmet <- eempf_residuals_metrics(resid, cpl_all))
```

#### Split-Half Analysis

```{r Split-Half}
#### SH Analysis Checks Convergence of Model ####
sp <-
  splithalf(
    eem_list_done,
    comps = 5,
    rand = FALSE,
    normalise = TRUE,
    nstart = 20,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 2500,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(sp)
splithalf_tcc(sp)

# SH with Randomized Selection
spr <-
  splithalf(
    eem_list_done,
    comps = 5,
    rand = TRUE,
    normalise = TRUE,
    nstart = 20,
    cores = parallel::detectCores(logical = FALSE),
    maxit = 2500,
    ctol = 10^(-7),
    rescale = TRUE,
    strictly_converging = FALSE,
    verbose = FALSE
  )

splithalf_plot(spr)
splithalf_tcc(spr)
```

### Final Model Checks

#### Core Consistency

```{r core-consistency}
eempf_corcondia(pf_final[[1]], 
                eem_list_done)
```

#### EEMqual

```{r EEMqual}
eempf_eemqual(pf_final[[1]], 
              eem_list_done, 
              spr, 
              cores = cores)
```

#### Component Importance

```{r comp-importance}
(eempf_varimp(pf_final[[1]], 
             eem_list_done, 
             cores = cores))
```

#### Shift and Shape Sensitive Congruence Coefficient

```{r scc-final-model}
ssccheck <- eempf_ssccheck(pf_final[[1]]$models, best = 3, cores = cores) # best 3 models are shown

eempf_plot_ssccheck(ssccheck)
```

------------------------------------------------------------------------

## Model Output

Some of these reports are a little redundant to the 4_get-peaks-and-slopes R code. 

```{r save-PARAFAC-model}
saveRDS(pf_final, file = paste0(folder_path, dim, "-comp-final-model_", Sys.Date(), ".rds" ))
```

```{r set-model-component-names}
# set new model names, number of models must be equal to number of names
eempf_comp_names(pf_final) <- c("C1","C2","C3","C4","C5")
```

```{r create-model-report}
absorbance <- absorbance_read("~/projects/Ch2_DOM/processed-data/abs-for-analysis", recursive = T, cores = cores)
absorbance <- abs_blcor(absorbance, wlrange = c(680, 700))

eempf_report(pf_final[[1]], 
             export = paste0("~/projects/Ch2_DOM/output/ch2_parafac_report_", Sys.Date(), ".html"), 
             eem_list = eem_list_done, 
             absorbance = absorbance,
             shmodel = sp, 
             performance = TRUE, 
             residuals = TRUE)
```

```{r save-components-and-operfluor}
# component breakdown 
factor_table <- 
  eempf_export(pf_final[[1]], Fmax = TRUE) %>%
  readr::write_csv(paste0("~/projects/Ch2_DOM/output/ch2_PARAFAC-model-results_", Sys.Date(), ".csv"))

# OpenFluor report
eempf_openfluor(pf_final[[1]], file = paste0("~/projects/Ch2_DOM/output/ch2_PARAFAC_openfluor_", Sys.Date(), ".txt"))
```

```{r parafac-index-abs-report}
eempf_analysis <- 
  eempf4analysis(
  pf_final[[1]],
  eem_list = eem_list_done,
  absorbance = absorbance,
  cuvl = 1,
  n = 5,
  export = NULL,
  cores = parallel::detectCores(logical = FALSE)
)
```

```{r rename-samples}
eempf_analysis$sampleid <-
  str_extract(eempf_analysis$sample, "([B]\\d+S\\d{1,2})")

eempf_analysis$site <-
  str_extract(eempf_analysis$sample, "(Blank1|Blank2|Blank3|Blank4|Blank5|HAT|HOGDN|HOGUP|POS|SWBUP|SWB|TUM)")

eempf_analysis$date <- 
  str_extract(eempf_analysis$sample, "(?<=_)(\\d{4})[[:alpha:]]\\w+\\d{2}")
  
eempf_analysis$dilution <- 
  str_extract(eempf_analysis$sample, "(dil+\\d{1})")

eempf_analysis$date <-  lubridate::ymd(eempf_analysis$date)

eempf_analysis
```


```{r export-peaks-indicies-and-comps}
readr::write_csv(eempf_analysis, paste0("~/projects/Ch2_DOM/output/ch2_full-report_", Sys.Date(), ".csv"))
```

